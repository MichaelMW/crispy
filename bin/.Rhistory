X_stack <- stack(X)
colnames(X_stack) <- c("Read","Exp")
ggplot(X_stack, aes(x=Exp, y=log10(Read+1))) +
geom_violin() +
theme_classic()
ggplot(X_stack, aes(x=Exp, y=log10(Read+1))) +
geom_violin() +
geom_boxplot() +
theme_classic()
ggplot(X_stack, aes(x=Exp, y=log10(Read+1))) +
geom_violin(position = dodge) +
geom_boxplot(position = dodge) +
theme_classic()
ggplot(X_stack, aes(x=Exp, y=log10(Read+1))) +
geom_violin() +
geom_boxplot(width=0.1) +
theme_classic()
qnorm
bgs
fgs
ggplot(X_stack, aes(x=Exp, y=log10(Read+1))) +
geom_violin() +
+stat_summary(fun.data=mean_sdl, mult=1,
geom="pointrange", color="red")+
theme_classic()
ggplot(X_stack, aes(x=Exp, y=log10(Read+1))) +
geom_violin() +
geom_boxplot(width=0.1) +
theme_classic()
ggplot(X_stack, aes(x=Exp, y=log10(Read+1))) +
geom_violin() +
geom_dotplot(binaxis='y', stackdir='center', dotsize=1) +
theme_classic()
ggplot(X_stack, aes(x=Exp, y=log10(Read+1))) +
geom_violin() +
stat_summary(fun.y=mean, geom="point", shape=23, size=2)+
theme_classic()
ggplot(X_stack, aes(x=Exp, y=log10(Read+1))) +
geom_violin() +
stat_summary(fun.y=median, geom="point", shape=23, size=2, color = "red")+
theme_classic()
ggplot(X_stack, aes(x=Exp, y=log10(Read+1))) +
geom_violin() +
stat_summary(fun.y=median, geom="point", size=2, color="red")
theme_classic()
ggplot(X_stack, aes(x=Exp, y=log10(Read+1))) +
geom_violin() +
stat_summary(fun.y=median, geom="point", shape=23, size=2, color = "red")+
theme_classic()
ggplot(X_stack, aes(x=Exp, y=log10(Read+1))) +
geom_violin() +
stat_summary(fun.y=median, geom="point", size=2, color = "red")+
theme_classic()
ggplot(X_stack, aes(x=Exp, y=log10(Read+1))) +
geom_violin() +
geom_boxplot(width = 0.1) +
stat_summary(fun.y=median, geom="point", size=2, color = "red")+
theme_classic()
ggplot(X_stack, aes(x=Exp, y=log10(Read+1))) +
geom_violin() +
geom_boxplot(width = 0.1) +
theme_classic()
ggplot(X_stack, aes(x=Exp, y=log10(Read+1))) +
geom_violin() +
geom_boxplot(width = 0.1, outlier.size = 0, coef = 0) +
theme_classic()
ggplot(X_stack, aes(x=Exp, y=log10(Read+1))) +
geom_violin() +
geom_boxplot(width = 0.1, coef = 0) +
theme_classic()
?geom_boxplot
ggplot(X_stack, aes(x=Exp, y=log10(Read+1))) +
geom_violin() +
geom_boxplot(width = 0.1, coef = 0, notch=T) +
theme_classic()
ggplot(X_stack, aes(x=Exp, y=log10(Read+1))) +
geom_violin() +
geom_boxplot(width = 0.1, outlier.size = 0,coef = 0, notch=T) +
theme_classic()
ggplot(X_stack, aes(x=Exp, y=log10(Read+1))) +
geom_violin() +
geom_boxplot(width = 0.1, outlier.shape = NA, coef = 0, notch=T) +
theme_classic()
ggplot(X_stack, aes(x=Exp, y=log10(Read+1))) +
geom_violin() +
geom_boxplot(width = 0.1, outlier.shape = NA, coef = 0) +
theme_classic()
ggplot(X_stack, aes(x=Exp, y=log10(Read+1))) +
geom_violin() +
geom_boxplot(width = 0.1, outlier.shape = NA) +
theme_classic()
head(X_stack)
ggplot(X_stack, aes(x=Read, color=Exp)) + geom_step()
ggplot(X_stack, aes(x=Read, color=Exp)) +stat_ecdf(geom = "step")
ggplot(X_stack, aes(x=log(Read+1), color=Exp)) +
stat_ecdf(geom = "step") +
theme_classic()
ggplot(X_stack, aes(x=log(Read+1), color=Exp)) +
stat_ecdf(geom = "step") +
xlab("Normalized reads counts (log(Read+1))") +
ylab("Cumulative frequency") +
theme_classic()
ggplot(X_stack, aes(x=log(Read+1), color=Exp)) +
stat_ecdf(geom = "point") +
xlab("Normalized reads counts (log(Read+1))") +
ylab("Cumulative frequency") +
theme_classic()
?stat_ecdf
ggplot(X_stack, aes(x=log(Read+1), color=Exp)) +
stat_ecdf(geom = "line") +
xlab("Normalized reads counts (log(Read+1))") +
ylab("Cumulative frequency") +
theme_classic()
distro1 <- ggplot(X_stack, aes(x=Exp, y=log10(Read+1))) +
geom_violin() +
geom_boxplot(width = 0.1, outlier.shape = NA) +
theme_classic()
ggplot(X_stack, aes(x=Exp, y=log10(Read+1))) +
geom_violin() +
geom_boxplot(width = 0.1, outlier.shape = NA) +
theme_classic()
outQcPlot = "debug.plot.pdf"
pdf(outQcPlot, width = 10, height = 12)
grid.arrange(distr1, distr2, ppca1, ppca2, p1, p2, nrow = 3)
dev.off()
distr1 <- ggplot(X_stack, aes(x=Exp, y=log10(Read+1))) +
geom_violin() +
geom_boxplot(width = 0.1, outlier.shape = NA) +
xlab("Experiments") +
ylab("Normalized reads counts (log(Read+1))") +
theme_classic()
### cumulative percentile ###
distr2 <- ggplot(X_stack, aes(x=log(Read+1), color=Exp)) +
stat_ecdf(geom = "line") +
xlab("Normalized reads counts (log(Read+1))") +
ylab("Cumulative frequency") +
theme_classic()
### plot PCA with all reads.
# pca1
cat("Running PCA on sgRNAs ...\n")
ppca1 <- autoplot(prcomp(X), data=dat, colour = colnames(dat)[dim(dat)[2]],
loadings = T,
loadings.colour = 'blue',
loadings.label = T) + theme_classic()
# pca2
cat("Running PCA on experiments ...\n")
tX <- as.data.frame(t(dat[,nSamp]))
ppca2 <- autoplot(prcomp(tX), label = TRUE, shape = FALSE) + theme_classic()
### negative binomial test
cat("Negative binomial test on sgRNAs ...\n")
dlist = DGEList(as.matrix(reads))
if(hasRep==1){
d = estimateDisp(calcNormFactors(dlist), design)
fit = glmQLFit(d, design, robust=TRUE)
results = glmQLFTest(fit)
}else{
d = estimateGLMCommonDisp(dlist, method="deviance", robust=TRUE, subset=NULL)
fit <- glmFit(d, design)
results <- glmLRT(fit)
}
tab = cbind(results$table, status)
rownames(tab) = dat[,1]
## preview and output
cat("preview top results:\n")
topTags(results)
outTsv=paste0(outDir, "/", paste0(prefix, ".sgRNA.tsv"))
write.table(format(tab,digits =4), file=outTsv, quote=FALSE, sep='\t')
## plotting QC
# fc.vs.cpm
p1 <- ggplot(tab, aes(x=logCPM,y=logFC)) +
geom_point(aes(colour = status), size = 1) + theme_classic()
# pval.vs.fc
p2 <- ggplot(tab, aes(x=logFC,y=PValue)) +
geom_point(aes(colour = status), size = 1) + theme_classic()
outQcPlot = "debug.plot.pdf"
pdf(outQcPlot, width = 10, height = 12)
grid.arrange(distr1, distr2, ppca1, ppca2, p1, p2, nrow = 3)
dev.off()
quantile(X, 10)
quantile(X, 0.1)
rowQuantiles(X, 0.1)
apply(X,2,function(x) quantile(c(0.1,0.9),na.rm=T))
apply(X,2,quantile, probs = c(0.1,0.9, na.rm=T))
apply(X,2,quantile, probs = c(0.1,0.9), na.rm=T)
ggplot(X_stack, aes(x=log(Read+1))) +
stat_ecdf(geom = "line") +
xlab("Normalized reads counts (log10(Read+1))") +
ylab("Cumulative frequency") +
theme_classic()
ggplot(X_stack, aes(x=Read)) +
stat_ecdf(geom = "line") +
xlab("Normalized reads counts (log10(Read+1))") +
ylab("Cumulative frequency") +
theme_classic()
ggplot(X_stack, aes(x=log(Read+1))) +
stat_ecdf(geom = "line") +
xlab("Normalized reads counts (log10(Read+1))") +
ylab("Cumulative frequency") +
theme_classic()
ggplot(X_stack, aes(x=log(Read+1), color=Exp)) +
stat_ecdf(geom = "line") +
xlab("Normalized reads counts (log10(Read+1))") +
ylab("Cumulative frequency") +
theme_classic()
apply(X,2,quantile, probs = c(0.1,0.9), na.rm=T)
apply(X,2,quantile, probs = c(0.25,0.75), na.rm=T)
apply(X,2,quantile, probs = c(0.25,0.75))
apply(X,2,quantile, probs = c(0.25,0.5, 0.75,1))
desc_statby
?desc_statby
tab
distr_tab <- apply(X,2,quantile, probs = c(0.25,0.5, 0.75,1))
ggtexttable(distr_tab, rows = NULL,
theme = ttheme("mOrange"))
distr_tab <- round(apply(X,2,quantile, probs = c(0.25,0.5, 0.75,1)),2)
ggtexttable(distr_tab, rows = NULL,
theme = ttheme("mOrange"))
ggtexttable(distr_tab, theme = ttheme("mOrange"))
rownames(distr_tab)
rownames(distr_tab) <-c("Read", "Q1", "Q2", "Q3","Q4")
rownames(distr_tab) <-c("Q1", "Q2", "Q3","Q4")
ggtexttable(distr_tab, theme = ttheme("mOrange"))
distr_tab <- round(apply(X,2,quantile, probs = c(0.25,0.5, 0.75,1)),2)
ggtexttable(distr_tab, theme = ttheme("mOrange"))
distr_tab <- round(apply(X,2,quantile, probs = c(0.25,0.5, 0.75)),2)
ggtexttable(distr_tab, theme = ttheme("mOrange"))
distr2.1 <- ggplot(X_stack, aes(x=log(Read+1), color=Exp)) +
stat_ecdf(geom = "line") +
xlab("Normalized reads counts (log10(Read+1))") +
ylab("Cumulative frequency") +
theme_classic()
### table. Fold_change = (90% read count)/(10% read count)
distr_tab <- round(apply(X,2,quantile, probs = c(0.25,0.5, 0.75)),2)
distr2.2 <- ggtexttable(distr_tab, theme = ttheme("mOrange"))
distr2 <- grid.arrange(distr2.1, distr2.2, nrow = 2)
distr
distr2
distr2
grid.arrange(distr2.1, distr2.2, nrow = 2)
distr2 <- grid.arrange(distr2.1, distr2.2, nrow = 2)
distr2
distr2.1 + annotation_custom(distr2.2)
distr2.1 + annotation_custom(ggplotGrob(distr2.2))
ggtexttable(distr_tab, theme = ttheme("classic"))
distr_tab <- round(apply(X,2,quantile, probs = c(0,0.25,0.5, 0.75,1)),2)
distr2.2 <- ggtexttable(distr_tab, theme = ttheme("classic"))
distr2.2
distr2.1
distr2.2
lay <- rbind(c(1,1,2,2),
c(1,1,3,3))
g.distr <- arrangeGrob(distr1, distr2.1, distr2.2, layout_matrix = lay)
g.distr
g1 <- arrangeGrob(distr1, distr2.1, distr2.2, layout_matrix = lay)
g2 <- arrangeGrob(ppca1, ppca2, nrow = 1)
g3 <- arrangeGrob(p1, p2, nrow = 1)
grid.arrange(g1, g2, g3, ncol=3)
grid.arrange(g1, g2, g3, nrow=3)
distr2 <- ggplot(X_stack, aes(x=log(Read+1), color=Exp)) +
stat_ecdf(geom = "line") +
xlab("Normalized reads counts (log10(Read+1))") +
ylab("Cumulative frequency") +
theme_classic()
outQcPlot = "debug.plot.pdf"
pdf(outQcPlot, width = 10, height = 12)
grid.arrange(distr1, distr2, ppca1, ppca2, p1, p2, nrow = 3)
dev.off()
?png
?pdf
?png
qtab
grid.arrange(distr1, distr2, ppca1, ppca2, p1, p2, distr2_tab, nrow = 4)
grid.arrange(distr1, distr2, ppca1, ppca2, p1, p2, distr2.2, nrow = 4)
distr2_tab <- ggtexttable(qtab, theme = ttheme("classic"))
qtab <- round(apply(X,2,quantile, probs = c(0,0.25,0.5, 0.75,1)), 2)
distr2_tab <- ggtexttable(qtab, theme = ttheme("classic"))
outTsv = "test.tsv"
write.table(format(distr2_tab), file=outTsv, quote=FALSE, sep='\t')
write.table(qtab, file=outTsv, quote=FALSE, sep='\t')
library(preprocessCore)
library(statmod)
library(edgeR)
library(gridExtra)
library(ggfortify)
library(ggplot2)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
inFile = "../demos/d1.Yarui/data.tsv"
fgs=c("cis1","cis2","cis3","cis4","cis5")
bgs=c("ctr1","ctr2")
qnorm = 0
min_cpm = 5
min_cpm_ratio = 0.5
### hardcoded parameter
negLabel = "negative"
testLabel = "test"
qcutoffs = c(0, 0.001, 0.005, 0.01, 0.05, 0.1) # pvalue guidelines help to aim at these qcutoffs.
### read data.
dat = read.table(inFile, header = T)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
inFile = "../demos/d6.Dppa2/reads.tsv"
bgs=c("S1.Unsorted","S2.Unsorted")
fgs=c("S1.GpMn","S2.GpMn")
qnorm = 0
min_cpm = 5
min_cpm_ratio = 0.5
### hardcoded parameter
negLabel = "negative"
testLabel = "test"
qcutoffs = c(0, 0.001, 0.005, 0.01, 0.05, 0.1) # pvalue guidelines help to aim at these qcutoffs.
dat = read.table(inFile, header = T)
### derived values and more warnings
nCol = dim(dat)[2]
allExps = c(2:(nCol-1))
## check qnorm parameter.
# convert qnorm string input to list
str2lists <- function(inStr){
a = strsplit(inStr,";")[[1]]
b = strsplit(a,",")
return(b)
}
if(grepl(",", qnorm, fixed=TRUE)){
qnormLists = str2lists(qnorm)
qnormFlat = unlist(qnormLists)
if(all(qnormFlat %in% colnames(dat)[allExps]) == FALSE) stop("Specified qnorm experiments not in read count header!")
for (qnormList in qnormLists){
qnormArray = unlist(qnormList)
if(length(qnormArray)<=1) stop("Needs 2 or more specified experiments for each qnorm group!")
}
}
## check number of rep
if(length(fgs)==1 || length(bgs)==1){
cat("#### Warning: ####\n
no biological replicates provided, using pooled fg/bg for dispersion estimation\n
For details, checkout estimateGLMCommonDisp in edgeR.\n\n")
hasRep = 0
}else{
hasRep = 1
}
################## preprocessing #####################
### quantile normalization of reads
qnormFun <- function(df){
mat = data.matrix(df)
df.qnorm = as.data.frame(normalize.quantiles(mat))
rownames(df.qnorm) = rownames(df)
colnames(df.qnorm) = colnames(df)
return(df.qnorm)
}
## qnorm at given named columns, in place.
qnormCols <- function(df, cols){
df[,cols] = qnormFun(df[,cols])
return(df)
}
## run qnorm
if(qnorm=="1"){
cat("qnorm within fgs and within bgs\n")
if(length(fgs)>1) dat = qnormCols(dat, fgs)
if(length(bgs)>1) dat = qnormCols(dat, bgs)
}else if(grepl(",", qnorm, fixed=TRUE)){
cat("qnorm in the specified columns\n")
for(qnormList in str2lists(qnorm)){
qnormArray = unlist(qnormList)
dat = qnormCols(dat, qnormArray)
}
}
cat("Plotting distribution of sgRNA reads ...\n")
X = data.frame(dat[, allExps])
X_stack = stack(X)
colnames(X_stack) <- c("Read","Exp")
distr1 <- ggplot(X_stack, aes(x=Exp, y=log10(Read+1))) +
geom_violin() +
geom_boxplot(width = 0.1, outlier.shape = NA) +
xlab("Experiments") +
ylab("Reads counts (log10(Read+1))") +
theme_classic()
distr1
### PCA on all reads. ###
cat("Running PCA ...\n")
## pca1 # view by sgRNAs
ppca1 <- autoplot(prcomp(X), data=dat, colour = colnames(dat)[dim(dat)[2]],
loadings = T,
loadings.colour = 'blue',
loadings.label = T,
size = 0.5) + theme_classic()
## pca2 # view by experiments
tX <- as.data.frame(t(X))
ppca2 <- autoplot(prcomp(tX),
label = TRUE,
loadings.label.repel=T,
shape = FALSE) + theme_classic()
ppca1
ppca2
bgs=c("U1","U2")
fgs=c("Mn1","Mn2")
qnorm = 0
min_cpm = 5
min_cpm_ratio = 0.5
row.use.fgs = (rowMeans(data.frame(dat[,c(fgs)] > min_cpm)) >= min_cpm_ratio)
row.use.bgs = (rowMeans(data.frame(dat[,c(bgs)] > min_cpm)) >= min_cpm_ratio)
row.use = (row.use.fgs | row.use.bgs)
dat.filtered = dat[row.use, ]
nsgRNA = dim(dat)[1]
nsgRNA.filtered = dim(dat.filtered)[1]
msg = paste0("min_cpm: ", round(min_cpm,2), "\n",
"min_cpm_ratio: ", round(min_cpm_ratio,2), "\n",
nsgRNA.filtered, "/", nsgRNA," (", round(nsgRNA.filtered/nsgRNA*100,2), "%)")
X = data.frame(FGs = rowMeans(data.frame(dat.filtered[,c(fgs)])),
BGs = rowMeans(data.frame(dat.filtered[,c(bgs)])))
X_stack = stack(X)
colnames(X_stack) <- c("Read","Exp")
distr2 <- ggplot(X_stack, aes(x=log10(Read+1), color=Exp)) +
stat_ecdf(geom = "line") +
xlab("Filtered normalized reads counts -- Log10(N+1)") +
ylab("Cumulative frequency") +
annotate("text",x=max(log10(X_stack$Read+1)),y=0,label=msg, hjust=1, vjust = 0) +
theme_classic()
distr2
X = data.frame(FGs = rowMeans(log10(data.frame(dat.filtered[,c(fgs)])+1)),
BGs = rowMeans(log10(data.frame(dat.filtered[,c(bgs)])+1)),
Group = dat.filtered[,nCol])
distr3 <- ggplot(X, aes(x=BGs, y=FGs, color=Group)) +
geom_point(alpha = 0.3, size = 0.5) +
geom_point(size = 0.5, data = subset(X, Group!=testLabel)) +
xlab("Filtered normalized reads counts in BGs -- Log10(N+1)") +
ylab("Filtered normalized reads counts in FGs") +
theme_classic()
distr3
cat("Negative binomial test on sgRNAs ...\n")
status = as.factor(dat.filtered[,nCol])
group = c(rep("fg", length(fgs)), rep("bg", length(bgs)))
design = model.matrix(~group)
reads = dat.filtered[,c(fgs,bgs)]
dlist = DGEList(as.matrix(reads))
if(hasRep==1){
d = estimateDisp(calcNormFactors(dlist), design)
fit = glmQLFit(d, design, robust=TRUE)
results = glmQLFTest(fit)
}else{
d = estimateGLMCommonDisp(dlist, method="deviance", robust=TRUE, subset=NULL)
fit <- glmFit(d, design)
results <- glmLRT(fit)
}
tab = cbind(results$table, status)
rownames(tab) = dat.filtered[,1]
tab = tab[order(tab$PValue),]  # sort by pval
## preview and output
cat("preview top results:\n")
topTags(results)
## plotting QC
# highlight postive sgRNA with pvalue < cutoff.
if(pvalCut > 0){
tab$status <- as.character(tab$status)
# default. only positive FC
if(direction == 1){
filteredIdx = (tab$PValue < pvalCut & tab$status==testLabel & tab$logFC>0)
posSgrnaMsg = paste0("Enriched sgRNA p < ", pvalCut)
}
# only negative FC
if(direction == -1){
filteredIdx = (tab$PValue < pvalCut & tab$status==testLabel & tab$logFC<0)
posSgrnaMsg = paste0("Depleted sgRNA p < ", pvalCut)
}
tab[filteredIdx, "status"] = posSgrnaMsg
}
# fc.vs.cpm. The MA plot
p1 <- ggplot(tab, aes(x=logCPM,y=logFC, colour = status)) +
geom_point(size = 0.5) +
geom_point(size = 0.5, data = subset(tab, status!=testLabel)) +
theme_classic()
# pval.vs.fc
p2 <- ggplot(tab, aes(x=logFC,y=PValue, colour = status)) +
geom_point(size = 0.5) +
geom_point(size = 0.5, data = subset(tab, status!=testLabel)) +
theme_classic()
tab_pvals = tab[,c("PValue","logFC","status")]
pvalDistro <- ggplot(tab_pvals, aes(x=status, y=-log10(PValue))) +
geom_violin() +
geom_boxplot(width = 0.1) +
xlab("sgRNA group") +
ylab("-log10(pval)") +
scale_y_continuous(breaks=seq(0,max(-log10(tab_pvals$PValue)),1)) +
theme(panel.grid.major.y = element_line(colour = "black", linetype = "dashed"),
panel.grid.major.x = element_blank(),
panel.grid.minor.x = element_blank(),
panel.background = element_rect(fill = "white",colour = "black"))
qval2pval <- function(qcutoffs, pvals, status, testLabel, negLabel){
df.pval = data.frame(pvals= pvals,status = status)
df.pval = subset(df.pval, status %in% c(testLabel, negLabel))
df.pval$status = as.factor(as.character(df.pval$status))
df.pval.sorted = df.pval[order(df.pval$pvals),]
N_recNeg = cumsum(df.pval.sorted$status == negLabel)
N_allNeg = sum(status==negLabel)
dfm = data.frame(df.pval.sorted,
FDR = N_recNeg/N_allNeg)
idx = 1:nrow(dfm)
df.q2p = data.frame()
for(qcutoff in qcutoffs){
pcutoff = dfm[max(idx[dfm$FDR <= qcutoff]),]$pval
pcutoff = round(pcutoff,5)
df.q2p = rbind(df.q2p, data.frame(qcutoff = qcutoff,
pcutoff = pcutoff))
}
return(df.q2p)
}
msg = qval2pval(qcutoffs, tab$PValue, tab$status, testLabel, negLabel)
q2pGuideTab = tableGrob(msg, rows = NULL)
## output all figures to file
outQcPlot.width = 15
outQcPlot.height = 12
png.res = 200 # ppi
outQcPlot
grid.arrange(distr1, ppca1, ppca2, distr2, distr3, p1, p2, pvalDistro, q2pGuideTab, nrow = 3)
format(tab,digits =4)

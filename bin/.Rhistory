reads = cbind(reads.fgs,reads.bgs)
nSamp = c(2:(dim(dat)[2]-1))
X = dat[,nSamp]
}
### boxplot reads. ### use all columns in input dat.
cat("Plotting distribution of sgRNA reads ...\n")
X_stack <- stack(X)
colnames(X_stack) <- c("Read","Exp")
ggplot(X_stack, aes(x=Exp, y=log10(Read+1))) +
geom_violin() +
theme_classic()
typeof(dat)
typeof(X)
X = dat[,nSamp]
typeof(X)
head(X)
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
inFile = "../demos/d1.Yarui/data.tsv"
fgs=list("cis1", "cis2", "cis3", "cis4", "cis5")
bgs=list("high1", "high2","high3")
#qnorm="ctr1,ctr2,high1,high2"
qnorm=2
# check on rep
hasRep = 1
if(length(unlist(fgs))==1 || length(unlist(bgs))==1){
hasRep = 0
cat("#### Warning: ####\nno biological replicates provided, using pooled fg/bg for dispersion estimation\nFor details, checkout estimateGLMCommonDisp in edgeR.\n\n")
}
### input preprocessing
dat = read.table(inFile, header = T)
status = as.factor(dat[,dim(dat)[2]])
ncol = length(c(unlist(fgs), unlist(bgs)))
group = c(rep("fg", length(unlist(fgs))), rep("bg", length(unlist(bgs))))
design = model.matrix(~group)
reads.fgs = dat[,unlist(fgs)]
reads.bgs = dat[,unlist(bgs)]
nSamp = c(2:(dim(dat)[2]-1))
# quantile normalization of reads
qnormFun <- function(df){
mat = as.matrix(df)
df.qnorm = normalize.quantiles(mat)
rownames(df.qnorm) = rownames(df)
colnames(df.qnorm) = colnames(df)
return(df.qnorm)
}
# qnorm condition
if(qnorm=="1"){
if(length(unlist(fgs))>1){
reads.fgs = qnormFun(reads.fgs)
cat("using quantile normalization on foreground ...\n")
}
if(length(unlist(bgs))>1){
reads.bgs = qnormFun(reads.bgs)
cat("using quantile normalization on background ...\n")
}
# patch dat with qnormed reads in fg and bg
reads = cbind(reads.fgs,reads.bgs)
idxReplace = match(colnames(reads),colnames(dat))
dat[,idxReplace] <- reads
X = dat[,nSamp]
}else if(qnorm=="2"){
cat("using quantile normalization on reads from all experiments (warning: strong hypothesis!) ...\n")
reads = cbind(reads.fgs,reads.bgs)
nSamp = c(2:(dim(dat)[2]-1))
X = dat[,nSamp]
X = qnormFun(X)
X = dat[,nSamp] # hotfix to get typeof(X) to be consistently a list.
}else if(grepl(",",qnorm,fixed=TRUE)){
# qnorm the specified columns from input string "qnorm"
qnormArray = unlist(strsplit(qnorm,","))
cat(paste0("using specified experiments: ", qnorm, " to perform qnorm ...\n"))
# check arguments.
if(all(qnormArray %in% colnames(dat)[nSamp]) == FALSE){
stop("Error: Provided qnorm experiments doesn't agree with provided read count header!")
}
if(length(qnormArray)<=1){
stop("Error: too few specified experiments for qnorm!")
}
dat.qnormed = qnormFun(dat[,qnormArray])
dat[,qnormArray] <- dat.qnormed
reads.fgs = dat[,unlist(fgs)]
reads.bgs = dat[,unlist(bgs)]
reads = cbind(reads.fgs,reads.bgs)
X = dat[,nSamp]
}else{
cat("no quantile normalization is performed\n")
reads = cbind(reads.fgs,reads.bgs)
nSamp = c(2:(dim(dat)[2]-1))
X = dat[,nSamp]
}
### boxplot reads. ### use all columns in input dat.
cat("Plotting distribution of sgRNA reads ...\n")
X_stack <- stack(X)
colnames(X_stack) <- c("Read","Exp")
ggplot(X_stack, aes(x=Exp, y=log10(Read+1))) +
geom_violin() +
theme_classic()
min(X$cis1)
min(X$cis2)
min(X$cis3)
X = X[,nSamp] # hotfix to get typeof(X) to be consistently a list.
head(X)
test=as.list(X)
head(test)
# quantile normalization of reads
qnormFun <- function(df){
mat = as.matrix(df)
df.qnorm = as.data.frame(normalize.quantiles(mat))
rownames(df.qnorm) = rownames(df)
colnames(df.qnorm) = colnames(df)
return(df.qnorm)
}
# qnorm condition
if(qnorm=="1"){
if(length(unlist(fgs))>1){
reads.fgs = qnormFun(reads.fgs)
cat("using quantile normalization on foreground ...\n")
}
if(length(unlist(bgs))>1){
reads.bgs = qnormFun(reads.bgs)
cat("using quantile normalization on background ...\n")
}
# patch dat with qnormed reads in fg and bg
reads = cbind(reads.fgs,reads.bgs)
idxReplace = match(colnames(reads),colnames(dat))
dat[,idxReplace] <- reads
X = dat[,nSamp]
}else if(qnorm=="2"){
cat("using quantile normalization on reads from all experiments (warning: strong hypothesis!) ...\n")
reads = cbind(reads.fgs,reads.bgs)
nSamp = c(2:(dim(dat)[2]-1))
X = dat[,nSamp]
X = qnormFun(X)
}else if(grepl(",",qnorm,fixed=TRUE)){
# qnorm the specified columns from input string "qnorm"
qnormArray = unlist(strsplit(qnorm,","))
cat(paste0("using specified experiments: ", qnorm, " to perform qnorm ...\n"))
# check arguments.
if(all(qnormArray %in% colnames(dat)[nSamp]) == FALSE){
stop("Error: Provided qnorm experiments doesn't agree with provided read count header!")
}
if(length(qnormArray)<=1){
stop("Error: too few specified experiments for qnorm!")
}
dat.qnormed = qnormFun(dat[,qnormArray])
dat[,qnormArray] <- dat.qnormed
reads.fgs = dat[,unlist(fgs)]
reads.bgs = dat[,unlist(bgs)]
reads = cbind(reads.fgs,reads.bgs)
X = dat[,nSamp]
}else{
cat("no quantile normalization is performed\n")
reads = cbind(reads.fgs,reads.bgs)
nSamp = c(2:(dim(dat)[2]-1))
X = dat[,nSamp]
}
### boxplot reads. ### use all columns in input dat.
cat("Plotting distribution of sgRNA reads ...\n")
X_stack <- stack(X)
colnames(X_stack) <- c("Read","Exp")
ggplot(X_stack, aes(x=Exp, y=log10(Read+1))) +
geom_violin() +
theme_classic()
qnorm=1
# check on rep
hasRep = 1
if(length(unlist(fgs))==1 || length(unlist(bgs))==1){
hasRep = 0
cat("#### Warning: ####\nno biological replicates provided, using pooled fg/bg for dispersion estimation\nFor details, checkout estimateGLMCommonDisp in edgeR.\n\n")
}
### input preprocessing
dat = read.table(inFile, header = T)
status = as.factor(dat[,dim(dat)[2]])
ncol = length(c(unlist(fgs), unlist(bgs)))
group = c(rep("fg", length(unlist(fgs))), rep("bg", length(unlist(bgs))))
design = model.matrix(~group)
reads.fgs = dat[,unlist(fgs)]
reads.bgs = dat[,unlist(bgs)]
nSamp = c(2:(dim(dat)[2]-1))
# quantile normalization of reads
qnormFun <- function(df){
mat = as.matrix(df)
df.qnorm = as.data.frame(normalize.quantiles(mat))
rownames(df.qnorm) = rownames(df)
colnames(df.qnorm) = colnames(df)
return(df.qnorm)
}
# qnorm condition
if(qnorm=="1"){
if(length(unlist(fgs))>1){
reads.fgs = qnormFun(reads.fgs)
cat("using quantile normalization on foreground ...\n")
}
if(length(unlist(bgs))>1){
reads.bgs = qnormFun(reads.bgs)
cat("using quantile normalization on background ...\n")
}
# patch dat with qnormed reads in fg and bg
reads = cbind(reads.fgs,reads.bgs)
idxReplace = match(colnames(reads),colnames(dat))
dat[,idxReplace] <- reads
X = dat[,nSamp]
}else if(qnorm=="2"){
cat("using quantile normalization on reads from all experiments (warning: strong hypothesis!) ...\n")
reads = cbind(reads.fgs,reads.bgs)
nSamp = c(2:(dim(dat)[2]-1))
X = dat[,nSamp]
X = qnormFun(X)
}else if(grepl(",",qnorm,fixed=TRUE)){
# qnorm the specified columns from input string "qnorm"
qnormArray = unlist(strsplit(qnorm,","))
cat(paste0("using specified experiments: ", qnorm, " to perform qnorm ...\n"))
# check arguments.
if(all(qnormArray %in% colnames(dat)[nSamp]) == FALSE){
stop("Error: Provided qnorm experiments doesn't agree with provided read count header!")
}
if(length(qnormArray)<=1){
stop("Error: too few specified experiments for qnorm!")
}
dat.qnormed = qnormFun(dat[,qnormArray])
dat[,qnormArray] <- dat.qnormed
reads.fgs = dat[,unlist(fgs)]
reads.bgs = dat[,unlist(bgs)]
reads = cbind(reads.fgs,reads.bgs)
X = dat[,nSamp]
}else{
cat("no quantile normalization is performed\n")
reads = cbind(reads.fgs,reads.bgs)
nSamp = c(2:(dim(dat)[2]-1))
X = dat[,nSamp]
}
### boxplot reads. ### use all columns in input dat.
cat("Plotting distribution of sgRNA reads ...\n")
X_stack <- stack(X)
colnames(X_stack) <- c("Read","Exp")
ggplot(X_stack, aes(x=Exp, y=log10(Read+1))) +
geom_violin() +
theme_classic()
ggplot(X_stack, aes(x=Exp, y=log10(Read+1))) +
geom_violin() +
geom_boxplot() +
theme_classic()
ggplot(X_stack, aes(x=Exp, y=log10(Read+1))) +
geom_violin(position = dodge) +
geom_boxplot(position = dodge) +
theme_classic()
ggplot(X_stack, aes(x=Exp, y=log10(Read+1))) +
geom_violin() +
geom_boxplot(width=0.1) +
theme_classic()
qnorm
bgs
fgs
ggplot(X_stack, aes(x=Exp, y=log10(Read+1))) +
geom_violin() +
+stat_summary(fun.data=mean_sdl, mult=1,
geom="pointrange", color="red")+
theme_classic()
ggplot(X_stack, aes(x=Exp, y=log10(Read+1))) +
geom_violin() +
geom_boxplot(width=0.1) +
theme_classic()
ggplot(X_stack, aes(x=Exp, y=log10(Read+1))) +
geom_violin() +
geom_dotplot(binaxis='y', stackdir='center', dotsize=1) +
theme_classic()
ggplot(X_stack, aes(x=Exp, y=log10(Read+1))) +
geom_violin() +
stat_summary(fun.y=mean, geom="point", shape=23, size=2)+
theme_classic()
ggplot(X_stack, aes(x=Exp, y=log10(Read+1))) +
geom_violin() +
stat_summary(fun.y=median, geom="point", shape=23, size=2, color = "red")+
theme_classic()
ggplot(X_stack, aes(x=Exp, y=log10(Read+1))) +
geom_violin() +
stat_summary(fun.y=median, geom="point", size=2, color="red")
theme_classic()
ggplot(X_stack, aes(x=Exp, y=log10(Read+1))) +
geom_violin() +
stat_summary(fun.y=median, geom="point", shape=23, size=2, color = "red")+
theme_classic()
ggplot(X_stack, aes(x=Exp, y=log10(Read+1))) +
geom_violin() +
stat_summary(fun.y=median, geom="point", size=2, color = "red")+
theme_classic()
ggplot(X_stack, aes(x=Exp, y=log10(Read+1))) +
geom_violin() +
geom_boxplot(width = 0.1) +
stat_summary(fun.y=median, geom="point", size=2, color = "red")+
theme_classic()
ggplot(X_stack, aes(x=Exp, y=log10(Read+1))) +
geom_violin() +
geom_boxplot(width = 0.1) +
theme_classic()
ggplot(X_stack, aes(x=Exp, y=log10(Read+1))) +
geom_violin() +
geom_boxplot(width = 0.1, outlier.size = 0, coef = 0) +
theme_classic()
ggplot(X_stack, aes(x=Exp, y=log10(Read+1))) +
geom_violin() +
geom_boxplot(width = 0.1, coef = 0) +
theme_classic()
?geom_boxplot
ggplot(X_stack, aes(x=Exp, y=log10(Read+1))) +
geom_violin() +
geom_boxplot(width = 0.1, coef = 0, notch=T) +
theme_classic()
ggplot(X_stack, aes(x=Exp, y=log10(Read+1))) +
geom_violin() +
geom_boxplot(width = 0.1, outlier.size = 0,coef = 0, notch=T) +
theme_classic()
ggplot(X_stack, aes(x=Exp, y=log10(Read+1))) +
geom_violin() +
geom_boxplot(width = 0.1, outlier.shape = NA, coef = 0, notch=T) +
theme_classic()
ggplot(X_stack, aes(x=Exp, y=log10(Read+1))) +
geom_violin() +
geom_boxplot(width = 0.1, outlier.shape = NA, coef = 0) +
theme_classic()
ggplot(X_stack, aes(x=Exp, y=log10(Read+1))) +
geom_violin() +
geom_boxplot(width = 0.1, outlier.shape = NA) +
theme_classic()
head(X_stack)
ggplot(X_stack, aes(x=Read, color=Exp)) + geom_step()
ggplot(X_stack, aes(x=Read, color=Exp)) +stat_ecdf(geom = "step")
ggplot(X_stack, aes(x=log(Read+1), color=Exp)) +
stat_ecdf(geom = "step") +
theme_classic()
ggplot(X_stack, aes(x=log(Read+1), color=Exp)) +
stat_ecdf(geom = "step") +
xlab("Normalized reads counts (log(Read+1))") +
ylab("Cumulative frequency") +
theme_classic()
ggplot(X_stack, aes(x=log(Read+1), color=Exp)) +
stat_ecdf(geom = "point") +
xlab("Normalized reads counts (log(Read+1))") +
ylab("Cumulative frequency") +
theme_classic()
?stat_ecdf
ggplot(X_stack, aes(x=log(Read+1), color=Exp)) +
stat_ecdf(geom = "line") +
xlab("Normalized reads counts (log(Read+1))") +
ylab("Cumulative frequency") +
theme_classic()
distro1 <- ggplot(X_stack, aes(x=Exp, y=log10(Read+1))) +
geom_violin() +
geom_boxplot(width = 0.1, outlier.shape = NA) +
theme_classic()
ggplot(X_stack, aes(x=Exp, y=log10(Read+1))) +
geom_violin() +
geom_boxplot(width = 0.1, outlier.shape = NA) +
theme_classic()
outQcPlot = "debug.plot.pdf"
pdf(outQcPlot, width = 10, height = 12)
grid.arrange(distr1, distr2, ppca1, ppca2, p1, p2, nrow = 3)
dev.off()
distr1 <- ggplot(X_stack, aes(x=Exp, y=log10(Read+1))) +
geom_violin() +
geom_boxplot(width = 0.1, outlier.shape = NA) +
xlab("Experiments") +
ylab("Normalized reads counts (log(Read+1))") +
theme_classic()
### cumulative percentile ###
distr2 <- ggplot(X_stack, aes(x=log(Read+1), color=Exp)) +
stat_ecdf(geom = "line") +
xlab("Normalized reads counts (log(Read+1))") +
ylab("Cumulative frequency") +
theme_classic()
### plot PCA with all reads.
# pca1
cat("Running PCA on sgRNAs ...\n")
ppca1 <- autoplot(prcomp(X), data=dat, colour = colnames(dat)[dim(dat)[2]],
loadings = T,
loadings.colour = 'blue',
loadings.label = T) + theme_classic()
# pca2
cat("Running PCA on experiments ...\n")
tX <- as.data.frame(t(dat[,nSamp]))
ppca2 <- autoplot(prcomp(tX), label = TRUE, shape = FALSE) + theme_classic()
### negative binomial test
cat("Negative binomial test on sgRNAs ...\n")
dlist = DGEList(as.matrix(reads))
if(hasRep==1){
d = estimateDisp(calcNormFactors(dlist), design)
fit = glmQLFit(d, design, robust=TRUE)
results = glmQLFTest(fit)
}else{
d = estimateGLMCommonDisp(dlist, method="deviance", robust=TRUE, subset=NULL)
fit <- glmFit(d, design)
results <- glmLRT(fit)
}
tab = cbind(results$table, status)
rownames(tab) = dat[,1]
## preview and output
cat("preview top results:\n")
topTags(results)
outTsv=paste0(outDir, "/", paste0(prefix, ".sgRNA.tsv"))
write.table(format(tab,digits =4), file=outTsv, quote=FALSE, sep='\t')
## plotting QC
# fc.vs.cpm
p1 <- ggplot(tab, aes(x=logCPM,y=logFC)) +
geom_point(aes(colour = status), size = 1) + theme_classic()
# pval.vs.fc
p2 <- ggplot(tab, aes(x=logFC,y=PValue)) +
geom_point(aes(colour = status), size = 1) + theme_classic()
outQcPlot = "debug.plot.pdf"
pdf(outQcPlot, width = 10, height = 12)
grid.arrange(distr1, distr2, ppca1, ppca2, p1, p2, nrow = 3)
dev.off()
quantile(X, 10)
quantile(X, 0.1)
rowQuantiles(X, 0.1)
apply(X,2,function(x) quantile(c(0.1,0.9),na.rm=T))
apply(X,2,quantile, probs = c(0.1,0.9, na.rm=T))
apply(X,2,quantile, probs = c(0.1,0.9), na.rm=T)
ggplot(X_stack, aes(x=log(Read+1))) +
stat_ecdf(geom = "line") +
xlab("Normalized reads counts (log10(Read+1))") +
ylab("Cumulative frequency") +
theme_classic()
ggplot(X_stack, aes(x=Read)) +
stat_ecdf(geom = "line") +
xlab("Normalized reads counts (log10(Read+1))") +
ylab("Cumulative frequency") +
theme_classic()
ggplot(X_stack, aes(x=log(Read+1))) +
stat_ecdf(geom = "line") +
xlab("Normalized reads counts (log10(Read+1))") +
ylab("Cumulative frequency") +
theme_classic()
ggplot(X_stack, aes(x=log(Read+1), color=Exp)) +
stat_ecdf(geom = "line") +
xlab("Normalized reads counts (log10(Read+1))") +
ylab("Cumulative frequency") +
theme_classic()
apply(X,2,quantile, probs = c(0.1,0.9), na.rm=T)
apply(X,2,quantile, probs = c(0.25,0.75), na.rm=T)
apply(X,2,quantile, probs = c(0.25,0.75))
apply(X,2,quantile, probs = c(0.25,0.5, 0.75,1))
desc_statby
?desc_statby
tab
distr_tab <- apply(X,2,quantile, probs = c(0.25,0.5, 0.75,1))
ggtexttable(distr_tab, rows = NULL,
theme = ttheme("mOrange"))
distr_tab <- round(apply(X,2,quantile, probs = c(0.25,0.5, 0.75,1)),2)
ggtexttable(distr_tab, rows = NULL,
theme = ttheme("mOrange"))
ggtexttable(distr_tab, theme = ttheme("mOrange"))
rownames(distr_tab)
rownames(distr_tab) <-c("Read", "Q1", "Q2", "Q3","Q4")
rownames(distr_tab) <-c("Q1", "Q2", "Q3","Q4")
ggtexttable(distr_tab, theme = ttheme("mOrange"))
distr_tab <- round(apply(X,2,quantile, probs = c(0.25,0.5, 0.75,1)),2)
ggtexttable(distr_tab, theme = ttheme("mOrange"))
distr_tab <- round(apply(X,2,quantile, probs = c(0.25,0.5, 0.75)),2)
ggtexttable(distr_tab, theme = ttheme("mOrange"))
distr2.1 <- ggplot(X_stack, aes(x=log(Read+1), color=Exp)) +
stat_ecdf(geom = "line") +
xlab("Normalized reads counts (log10(Read+1))") +
ylab("Cumulative frequency") +
theme_classic()
### table. Fold_change = (90% read count)/(10% read count)
distr_tab <- round(apply(X,2,quantile, probs = c(0.25,0.5, 0.75)),2)
distr2.2 <- ggtexttable(distr_tab, theme = ttheme("mOrange"))
distr2 <- grid.arrange(distr2.1, distr2.2, nrow = 2)
distr
distr2
distr2
grid.arrange(distr2.1, distr2.2, nrow = 2)
distr2 <- grid.arrange(distr2.1, distr2.2, nrow = 2)
distr2
distr2.1 + annotation_custom(distr2.2)
distr2.1 + annotation_custom(ggplotGrob(distr2.2))
ggtexttable(distr_tab, theme = ttheme("classic"))
distr_tab <- round(apply(X,2,quantile, probs = c(0,0.25,0.5, 0.75,1)),2)
distr2.2 <- ggtexttable(distr_tab, theme = ttheme("classic"))
distr2.2
distr2.1
distr2.2
lay <- rbind(c(1,1,2,2),
c(1,1,3,3))
g.distr <- arrangeGrob(distr1, distr2.1, distr2.2, layout_matrix = lay)
g.distr
g1 <- arrangeGrob(distr1, distr2.1, distr2.2, layout_matrix = lay)
g2 <- arrangeGrob(ppca1, ppca2, nrow = 1)
g3 <- arrangeGrob(p1, p2, nrow = 1)
grid.arrange(g1, g2, g3, ncol=3)
grid.arrange(g1, g2, g3, nrow=3)
distr2 <- ggplot(X_stack, aes(x=log(Read+1), color=Exp)) +
stat_ecdf(geom = "line") +
xlab("Normalized reads counts (log10(Read+1))") +
ylab("Cumulative frequency") +
theme_classic()
outQcPlot = "debug.plot.pdf"
pdf(outQcPlot, width = 10, height = 12)
grid.arrange(distr1, distr2, ppca1, ppca2, p1, p2, nrow = 3)
dev.off()
?png
?pdf
?png
qtab
grid.arrange(distr1, distr2, ppca1, ppca2, p1, p2, distr2_tab, nrow = 4)
grid.arrange(distr1, distr2, ppca1, ppca2, p1, p2, distr2.2, nrow = 4)
distr2_tab <- ggtexttable(qtab, theme = ttheme("classic"))
qtab <- round(apply(X,2,quantile, probs = c(0,0.25,0.5, 0.75,1)), 2)
distr2_tab <- ggtexttable(qtab, theme = ttheme("classic"))
outTsv = "test.tsv"
write.table(format(distr2_tab), file=outTsv, quote=FALSE, sep='\t')
write.table(qtab, file=outTsv, quote=FALSE, sep='\t')
